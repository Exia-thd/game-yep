<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üê¥ ƒêua Ng·ª±a B·∫Øt C√∫p</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Sriracha&family=Quicksand:wght@600;700&display=swap');
    *{margin:0;padding:0;box-sizing:border-box;}
    body{
      font-family:'Quicksand',sans-serif;
      overflow:hidden;
      background:linear-gradient(135deg,#87CEEB 0%,#98D8E8 50%,#B0E8F5 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
    }
    #gameCanvas{
      display:block;
      background:linear-gradient(to bottom, #87CEEB 0%, #f0f8ff 30%, #90EE90 100%);
      border:5px solid #fff;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
      border-radius:15px;
      max-width:95vw;
      max-height:90vh;
    }

    .ui-overlay{position:fixed;inset:0;pointer-events:none;z-index:10;}

    .setup-panel{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      background:linear-gradient(145deg,rgba(255,255,255,0.95),rgba(255,248,240,0.95));
      padding:40px;border-radius:30px;
      box-shadow:0 20px 80px rgba(0,0,0,0.4), 0 0 40px rgba(245,87,108,0.3), inset 0 1px 0 rgba(255,255,255,0.8);
      pointer-events:all;max-width:520px;width:90%;
      max-height:85vh;overflow-y:auto;
      backdrop-filter:blur(20px);border:3px solid rgba(255,255,255,0.8);
      display:flex;flex-direction:column;
      animation:panelFloat 3s ease-in-out infinite;
    }
    @keyframes panelFloat{
      0%, 100%{transform:translate(-50%,-50%) translateY(0px);}
      50%{transform:translate(-50%,-50%) translateY(-5px);}
    }
    .setup-panel h1{
      font-family:'Sriracha',cursive;color:#f5576c;font-size:42px;text-align:center;
      margin-bottom:10px;text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 20px rgba(245,87,108,0.5);letter-spacing:1px;
      animation:titleGlow 2s ease-in-out infinite;
    }
    @keyframes titleGlow{
      0%, 100%{text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 20px rgba(245,87,108,0.5);}
      50%{text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 30px rgba(245,87,108,0.8), 0 0 40px rgba(245,87,108,0.4);}
    }
    .setup-panel p{text-align:center;color:#666;margin-bottom:22px;font-size:16px;font-weight:600;}

    .player-input-area{margin-bottom:18px;flex-shrink:0;}
    .player-input-area label{display:block;color:#f5576c;font-weight:700;margin-bottom:10px;font-size:16px;}
    #playerInput{
      width:100%;padding:15px;border:3px solid #f5576c;border-radius:15px;
      font-size:16px;font-family:'Quicksand',sans-serif;font-weight:600;
      background:#fff;min-height:150px;resize:vertical;line-height:1.6;
      transition:all .25s ease;
    }
    #playerInput:focus{
      outline:none;border-color:#ffd700;box-shadow:0 0 0 3px rgba(255,215,0,0.2);
      transform:translateY(-2px);
    }

    .btn{
      width:100%;padding:18px;font-size:20px;font-weight:700;font-family:'Quicksand',sans-serif;
      border:none;border-radius:15px;cursor:pointer;transition:all .25s ease;
      letter-spacing:0.5px;box-shadow:0 6px 20px rgba(0,0,0,0.2);
      pointer-events:all;
      display:flex;align-items:center;justify-content:center;
      text-align:center;
    }
    .btn-start{background:linear-gradient(135deg,#f093fb 0%,#f5576c 50%,#ffd700 100%);color:#fff;margin-top:10px;
      background-size:200% 100%;animation:gradientSlide 3s ease infinite;position:relative;overflow:hidden;}
    .btn-start::before{content:'';position:absolute;top:50%;left:50%;width:0;height:0;
      background:rgba(255,255,255,0.3);border-radius:50%;transform:translate(-50%,-50%);
      transition:width 0.6s, height 0.6s;}
    .btn-start:hover:not(:disabled)::before{width:300%;height:300%;}
    .btn-start:hover:not(:disabled){transform:translateY(-3px) scale(1.02);box-shadow:0 15px 40px rgba(245,87,108,0.6), 0 0 20px rgba(255,215,0,0.4);}
    @keyframes gradientSlide{
      0%, 100%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
    }
    .btn-start:disabled{opacity:.5;cursor:not-allowed;}

    .btn-random{
      background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      color:#fff;
      background-size:200% 100%;
      animation:gradientSlide 3s ease infinite;
    }
    .btn-random:hover{
      transform:translateY(-2px);
      box-shadow:0 10px 30px rgba(102,126,234,0.5);
    }

    .race-info{
      position:fixed;top:30px;left:50%;transform:translateX(-50%);
      background:linear-gradient(145deg,rgba(255,255,255,0.95),rgba(255,248,240,0.95));
      padding:18px 36px;border-radius:20px;
      box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 30px rgba(245,87,108,0.3);
      font-family:'Sriracha',cursive;font-size:28px;color:#f5576c;text-align:center;
      border:3px solid rgba(255,255,255,0.8);backdrop-filter:blur(20px);
      display:none;pointer-events:all;z-index:9998;
      animation:infoPulse 2s ease-in-out infinite;
    }
    @keyframes infoPulse{
      0%, 100%{box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 30px rgba(245,87,108,0.3);}
      50%{box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 40px rgba(245,87,108,0.6), 0 0 60px rgba(245,87,108,0.2);}
    }

    .winner-announcement{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);
      background:linear-gradient(145deg,#ffd700,#ffed4e,#ffd700);
      background-size:200% 200%;animation:rainbowShift 3s ease infinite;
      padding:60px;border-radius:30px;
      box-shadow:0 30px 100px rgba(0,0,0,0.5), 0 0 60px rgba(255,215,0,0.8), 0 0 100px rgba(255,215,0,0.4);
      text-align:center;border:5px solid #fff;
      z-index:9999;transition:transform .5s cubic-bezier(0.68,-0.55,0.265,1.55);
      pointer-events:all;
    }
    @keyframes rainbowShift{
      0%, 100%{background-position:0% 50%;filter:hue-rotate(0deg);}
      50%{background-position:100% 50%;filter:hue-rotate(20deg);}
    }
    .winner-announcement.show{transform:translate(-50%,-50%) scale(1);}
    .winner-announcement h2{
      font-family:'Sriracha',cursive;font-size:48px;color:#d63031;margin-bottom:18px;
      text-shadow:3px 3px 0 rgba(0,0,0,0.1);animation:pulse 1s infinite;
    }
    .winner-announcement .winner-name{
      font-size:56px;font-weight:700;color:#2d3436;margin:20px 0;
      text-shadow:2px 2px 0 rgba(255,255,255,0.8);word-break:break-word;
    }
    .winner-announcement .trophy{font-size:100px;animation:bounce .8s infinite;
      filter:drop-shadow(0 10px 20px rgba(255,215,0,0.6));}
    @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
    @keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-20px)}}

    .btn-restart{background:linear-gradient(135deg,#00b894,#00cec9);color:#fff;margin-top:26px;}
    .btn-restart:hover{transform:translateY(-3px);box-shadow:0 10px 30px rgba(0,184,148,0.4);}
    .hidden{display:none !important;}
  </style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay">
    <div id="setupPanel" class="setup-panel">
      <h1>üê¥ ƒêua Ng·ª±a B·∫Øt C√∫p</h1>
      <p>Nh·∫≠p danh s√°ch ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc ƒëua!</p>

      <div class="player-input-area">
        <label for="playerInput">Danh s√°ch ng∆∞·ªùi ch∆°i (m·ªói d√≤ng 1 ng∆∞·ªùi):</label>
        <textarea id="playerInput" placeholder="Nguy·ªÖn VƒÉn A
Tr·∫ßn Th·ªã B
L√™ VƒÉn C"></textarea>
        <button class="btn btn-random" id="randomBtn" style="margin-top:10px; background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#fff; padding:12px; font-size:16px;">
          üîÄ Random Danh S√°ch
        </button>
      </div>

      <div class="player-input-area">
        <label for="raceDuration">‚è±Ô∏è Th·ªùi gian ƒëua (gi√¢y):</label>
        <input type="number" id="raceDuration" min="1" value="120"
          style="width:100%; padding:15px; border:3px solid #f5576c; border-radius:15px;
                 font-size:16px; font-family:'Quicksand',sans-serif; font-weight:600;">
        <p style="font-size:14px;color:#666;margin-top:8px;">T·ªëi thi·ªÉu 1 gi√¢y</p>
      </div>

      <button class="btn btn-start" id="startBtn" disabled>üèÅ B·∫Øt ƒê·∫ßu ƒêua!</button>
    </div>

    <div id="raceInfo" class="race-info">
      üèÅ Cu·ªôc ƒëua ƒëang di·ªÖn ra! üèÅ<br>
      <span id="timeRemaining" style="font-size:20px;color:#ff6b6b;">‚è±Ô∏è 30s</span>
    </div>

    <div id="winnerPanel" class="winner-announcement hidden">
      <div class="trophy">üèÜ</div>
      <h2>üéâ Ng∆∞·ªùi Th·∫Øng Cu·ªôc üéâ</h2>
      <div class="winner-name" id="winnerName"></div>
      <button class="btn btn-restart" id="restartBtn">üîÑ Ch∆°i L·∫°i</button>
    </div>
  </div>

  <script>
    'use strict';

    // ===== Canvas Setup =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size
    function resizeCanvas() {
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = window.innerHeight * 0.85;
      const aspectRatio = 16 / 9;

      let width = maxWidth;
      let height = width / aspectRatio;

      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
      }

      canvas.width = Math.min(1400, width);
      canvas.height = Math.min(800, height);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ===== Helpers =====
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand  = (a, b) => a + Math.random() * (b - a);
    const pick  = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // Helper to make color darker/lighter
    function shadeColor(color, percent) {
      let R = parseInt(color.substring(1,3), 16);
      let G = parseInt(color.substring(3,5), 16);
      let B = parseInt(color.substring(5,7), 16);

      R = Math.max(0, Math.min(255, R + percent));
      G = Math.max(0, Math.min(255, G + percent));
      B = Math.max(0, Math.min(255, B + percent));

      const RR = R.toString(16).padStart(2, '0');
      const GG = G.toString(16).padStart(2, '0');
      const BB = B.toString(16).padStart(2, '0');

      return "#" + RR + GG + BB;
    }

    // ===== UI =====
    const setupPanel = document.getElementById('setupPanel');
    const playerInput = document.getElementById('playerInput');
    const startBtn = document.getElementById('startBtn');
    const randomBtn = document.getElementById('randomBtn');
    const raceDurationInput = document.getElementById('raceDuration');
    const raceInfo = document.getElementById('raceInfo');
    const winnerPanel = document.getElementById('winnerPanel');
    const winnerNameEl = document.getElementById('winnerName');
    const restartBtn = document.getElementById('restartBtn');

    // ===== State =====
    let players = [];
    let horses = [];
    let clouds = [];
    let trees = [];
    let obstacles = [];

    let eliminatedHorses = [];
    let totalPlayers = 0;

    // Horse sorting cache
    let sortedHorsesCache = [];
    let lastSortFrame = -1;

    // Pre-rendered horse canvases for better performance (avoid filter on every frame)
    const horseCanvasCache = new Map();

    // Performance settings based on player count
    let perfSettings = {
      drawShadows: true,
      drawParticles: true,
      drawComplexAura: true,
      drawTrees: true,
      drawClouds: true,
      simplifiedNameTags: false
    };

    // Load horse image
    const horseImg = new Image();
    horseImg.src = 'horse.gif';
    let horseImgLoaded = false;
    horseImg.onload = () => {
      horseImgLoaded = true;
    };

    let raceDuration = 120;
    let raceStartTime = 0;
    let winner = null;

    const MODE = { SETUP:'SETUP', RACING:'RACING', WIN_CINEMATIC:'WIN_CINEMATIC', ENDED:'ENDED' };
    let mode = MODE.SETUP;

    // ===== Background Music =====
    let backgroundMusic = new Audio();
    backgroundMusic.volume = 1.0;

    const musicTracks = [
      'Music/edm-gaming-music-335408.mp3',
      'Music/level-up-energetic-gaming-rock-music-251284.mp3',
      'Music/victory-awaits-in-the-gaming-universe_astronaut-265184.mp3',
      'Music/gaming-game-minecraft-background-music-372242.mp3',
      'Music/retro-game-402454.mp3'
    ];

    let currentTrackIndex = -1;

    function playRandomMusic() {
      if (musicTracks.length === 0) return;
      let newIndex;
      do {
        newIndex = Math.floor(Math.random() * musicTracks.length);
      } while (newIndex === currentTrackIndex && musicTracks.length > 1);

      currentTrackIndex = newIndex;
      backgroundMusic.src = musicTracks[currentTrackIndex];
      backgroundMusic.play().catch(err => console.log('Music play failed:', err));
    }

    function stopMusic() {
      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;
    }

    function playVictoryMusic() {
      backgroundMusic.src = 'Music/gaming-game-minecraft-background-music-387000.mp3';
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(err => console.log('Victory music play failed:', err));
    }

    // Auto play next track when current ends
    backgroundMusic.addEventListener('ended', () => {
      if (mode === MODE.RACING) {
        playRandomMusic();
      }
    });

    // Winner cinematic
    let winCine = { active: false, horse: null, phase: 'SPRINT', startAt: 0, finishAt: 0 };
    let cameraOffset = 0; // For scrolling background

    // Obstacle scheduler
    const maxEliminationPercent = 0.30;
    let nextObstacleAt = 0;
    let obstacleInProgress = false;
    const OBSTACLE_GAP_MIN = 5000;
    const OBSTACLE_GAP_MAX = 12000;

    // Overtake drama
    let nextOvertakeAt = 0;
    const OVERTAKE_GAP_MIN = 3000; // Reduced from 5000 for more frequent boosts
    const OVERTAKE_GAP_MAX = 5000; // Reduced from 6500 for more frequent boosts

    // Animation frame counter
    let frameCount = 0;

    // Frame rate limiting for better performance
    let lastFrameTime = 0;
    const TARGET_FPS = 60;
    let targetFrameTime = 1000 / TARGET_FPS;

    // ===== Drawing Functions =====
    function drawSky() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.25);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(1, '#E0F6FF');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height * 0.25);
    }

    function drawGround() {
      // Sky takes less space, track takes more
      const skyHeight = canvas.height * 0.25;

      // Grass
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(0, skyHeight, canvas.width, canvas.height * 0.1);

      // Track (dirt) - much larger now
      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(0, trackY, canvas.width, trackHeight);

      // Track lines
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, trackY);
      ctx.lineTo(canvas.width, trackY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, trackY + trackHeight);
      ctx.lineTo(canvas.width, trackY + trackHeight);
      ctx.stroke();

      // Grass texture lines (scrolling)
      ctx.strokeStyle = 'rgba(34,139,34,0.3)';
      ctx.lineWidth = 2;
      const grassSpacing = 40;
      const grassOffset = cameraOffset * 0.8;
      for (let x = -(grassOffset % grassSpacing); x < canvas.width; x += grassSpacing) {
        ctx.beginPath();
        ctx.moveTo(x, skyHeight);
        ctx.lineTo(x + 20, skyHeight + canvas.height * 0.1);
        ctx.stroke();
      }
    }

    function drawCloud(cloud) {
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      const x = cloud.x - cameraOffset * 0.3; // Parallax effect
      ctx.beginPath();
      ctx.arc(x, cloud.y, 35, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawTree(tree) {
      const x = tree.x - cameraOffset * 0.5; // Parallax effect
      // Simplified tree (emoji-style)
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(x, tree.y, 22, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawFinishLine() {
      // Finish line position in world space (far ahead of starting position)
      const finishLineWorldX = 3000; // Fixed position in world
      // Convert to screen space
      const x = finishLineWorldX - cameraOffset + canvas.width * 0.2;

      // Only draw if visible on screen
      if (x < -100 || x > canvas.width + 100) return;

      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;

      // Checkered flag pattern
      const squareSize = 15;
      for (let row = 0; row < Math.ceil(trackHeight / squareSize); row++) {
        for (let col = 0; col < 3; col++) {
          const isWhite = (row + col) % 2 === 0;
          ctx.fillStyle = isWhite ? '#fff' : '#000';
          ctx.fillRect(x + col * squareSize, trackY + row * squareSize, squareSize, squareSize);
        }
      }

      // Trophy at top
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('üèÜ', x + 22, trackY - 20);
    }

    function drawHorse(horse, laneIndex) {
      if (eliminatedHorses.includes(horse.name)) return;
      // Don't skip if image not loaded - draw placeholder instead

      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;

      // All horses run on the same track area with depth offset
      const centerY = trackY + trackHeight * 0.5 + horse.depthOffset;

      // Calculate screen position based on horse position minus camera offset
      let x;
      if (mode === MODE.WIN_CINEMATIC && horse.isWinner) {
        // Winner stays centered on screen at 50% as camera follows
        x = canvas.width * 0.5;
      } else {
        // Normal mode: position minus camera offset for scrolling effect
        x = horse.position - cameraOffset + canvas.width * 0.2;
      }

      const y = centerY;

      // Fixed scale for all - smaller for better performance
      let baseScale = 0.15; // Reduced from 0.2 for performance
      let scale = baseScale;

      // Calculate dimensions once
      const horseWidth = horseImg.width * scale;
      const horseHeight = horseImg.height * scale;

      // VIEWPORT CULLING - Skip drawing if horse is off-screen (major performance boost!)
      // BUT: Never cull the winner horse during cinematic mode!
      const isWinnerInCinematic = (mode === MODE.WIN_CINEMATIC && horse.isWinner);
      if (!isWinnerInCinematic && (x < -horseWidth * 2 || x > canvas.width + horseWidth * 2)) {
        return; // Don't draw horses outside viewport
      }

      // Gallop animation (gentle bounce)
      const gallopPhase = frameCount * 0.3 * (horse.speed / 2);
      let gallopOffset = Math.abs(Math.sin(gallopPhase)) * (5 * scale / baseScale);

      // BOOST JUMP - ng·ª±a bay l√™n cao v√† gi·ªØ ·ªü tr√™n khi b·ª©c t·ªëc! (ALWAYS VISIBLE)
      const boostCheckTime = Date.now();
      if (boostCheckTime < horse.scriptedBoostUntil && mode === MODE.RACING) {
        const boostDuration = 2200; // Duration of boost
        const elapsed = boostDuration - (horse.scriptedBoostUntil - boostCheckTime);
        const progress = elapsed / boostDuration; // 0 to 1

        let jumpHeight = 0;
        if (progress < 0.15) {
          // Bay l√™n cao nhanh (0-15% th·ªùi gian)
          const riseProgress = progress / 0.15;
          jumpHeight = Math.sin(riseProgress * Math.PI * 0.5) * 150; // TƒÉng t·ª´ 120 l√™n 150 pixels!
        } else if (progress < 0.85) {
          // Gi·ªØ ·ªü tr√™n cao (15-85% th·ªùi gian)
          jumpHeight = 150; // Gi·ªØ ·ªü ƒë·ªô cao max
          // Th√™m dao ƒë·ªông nh·∫π ƒë·ªÉ sinh ƒë·ªông
          jumpHeight += Math.sin(frameCount * 0.2) * 10;
        } else {
          // H·∫° xu·ªëng t·ª´ t·ª´ (85-100% th·ªùi gian)
          const fallProgress = (progress - 0.85) / 0.15;
          jumpHeight = 150 * (1 - Math.sin(fallProgress * Math.PI * 0.5));
        }

        gallopOffset += jumpHeight;
      }

      const horseY = y - gallopOffset;

      // Body bounce (minimal tilt)
      const bodyTilt = Math.sin(gallopPhase) * 0.015;

      ctx.save();
      ctx.translate(x, horseY);
      ctx.rotate(bodyTilt);

      // Draw animated horse GIF or colored rectangle as fallback
      // NOTE: CSS filter hue-rotate is VERY expensive, disabled for performance
      // Color variation is achieved through pre-rendered canvases or simple tinting
      if (horseImgLoaded) {
        // Use cached pre-rendered horse if available for better performance
        const cacheKey = `${horse.name}_${horse.hueRotate}`;
        let cachedCanvas = horseCanvasCache.get(cacheKey);

        if (!cachedCanvas && horseCanvasCache.size < 200) {
          // Pre-render horse with hue rotation (only once per horse)
          cachedCanvas = document.createElement('canvas');
          cachedCanvas.width = horseImg.width;
          cachedCanvas.height = horseImg.height;
          const cacheCtx = cachedCanvas.getContext('2d');

          // Apply color filter during pre-render (once), not every frame!
          // For many players (>50), skip filter to save memory and performance
          if (horses.length <= 50) {
            cacheCtx.filter = `hue-rotate(${horse.hueRotate}deg) saturate(1.3) brightness(1.1)`;
          } else {
            // For 50+ players, use lighter filter for performance
            cacheCtx.filter = `hue-rotate(${horse.hueRotate}deg)`;
          }
          cacheCtx.drawImage(horseImg, 0, 0);
          cacheCtx.filter = 'none';

          horseCanvasCache.set(cacheKey, cachedCanvas);
        }

        // Draw pre-rendered horse (much faster!)
        if (cachedCanvas) {
          ctx.drawImage(cachedCanvas, -horseWidth / 2, -horseHeight / 2, horseWidth, horseHeight);
        } else {
          // Fallback: draw without filter
          ctx.drawImage(horseImg, -horseWidth / 2, -horseHeight / 2, horseWidth, horseHeight);
        }
      } else {
        // Fallback: draw colored rectangle if image not loaded
        ctx.fillStyle = horse.color;
        ctx.fillRect(-horseWidth / 2, -horseHeight / 2, horseWidth, horseHeight);
        // Draw simple horse emoji as backup
        ctx.font = `${horseWidth * 0.6}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üê¥', 0, 0);
      }

      ctx.restore();

      // Boost aura - show when horse is in scripted boost
      const now = Date.now();
      if (now < horse.scriptedBoostUntil && mode === MODE.RACING) {
        ctx.save();

        if (perfSettings.drawComplexAura) {
          // Complex aura for low player counts
          ctx.globalAlpha = 0.7 + Math.sin(frameCount * 0.3) * 0.3;

          // Golden aura around boosting horse
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, horseWidth * 1.2);
          gradient.addColorStop(0, 'rgba(255, 215, 0, 0.95)');
          gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.6)');
          gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, horseWidth * 1.2, 0, Math.PI * 2);
          ctx.fill();

          // Lightning bolts - only draw every other frame for performance
          if (frameCount % 2 === 0) {
            ctx.strokeStyle = 'rgba(255, 255, 0, 1)';
            ctx.lineWidth = 4;
            for (let i = 0; i < 4; i++) {
              const angle = (frameCount * 0.15 + i * Math.PI * 2 / 4);
              const boltX = x + Math.cos(angle) * horseWidth * 0.7;
              const boltY = y + Math.sin(angle) * horseWidth * 0.7;
              ctx.beginPath();
              ctx.moveTo(boltX, boltY);
              ctx.lineTo(boltX + Math.cos(angle) * 20, boltY + Math.sin(angle) * 20);
              ctx.stroke();
            }
          }
        } else {
          // Simple glow for high player counts (MUCH faster!)
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = '#FFD700';
          ctx.beginPath();
          ctx.arc(x, y, horseWidth * 0.8, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      // Name tag - fixed position, no bouncing
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformation for name tag

      // Dynamic font size based on number of players (optimized)
      let fontSize = 28;
      if (horses.length > 50) fontSize = 18;
      else if (horses.length > 30) fontSize = 20;
      else if (horses.length > 20) fontSize = 22;
      else if (horses.length > 10) fontSize = 24;

      ctx.font = `bold ${fontSize}px Quicksand`;
      const nameWidth = ctx.measureText(horse.name).width + 20;

      const tagX = x - nameWidth/2;
      // Use centerY instead of horseY for stable position (adjusted for larger horse)
      const tagY = centerY - (horseHeight * 0.8);
      const tagHeight = fontSize + 8;

      if (perfSettings.simplifiedNameTags) {
        // Simple rectangle with colored border - MUCH faster for many players!
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillRect(tagX, tagY, nameWidth, tagHeight);

        // Colored border (thicker and more vibrant)
        ctx.strokeStyle = horse.color;
        ctx.lineWidth = 3;
        ctx.strokeRect(tagX, tagY, nameWidth, tagHeight);
      } else {
        // Rounded rectangle for name tag (prettier but slower)
        // Glow effect for better visibility
        ctx.shadowColor = horse.color;
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.fillStyle = 'rgba(255,255,255,0.98)';
        ctx.strokeStyle = horse.color;
        ctx.lineWidth = 3;

        const radius = 8;
        ctx.beginPath();
        ctx.moveTo(tagX + radius, tagY);
        ctx.lineTo(tagX + nameWidth - radius, tagY);
        ctx.quadraticCurveTo(tagX + nameWidth, tagY, tagX + nameWidth, tagY + radius);
        ctx.lineTo(tagX + nameWidth, tagY + tagHeight - radius);
        ctx.quadraticCurveTo(tagX + nameWidth, tagY + tagHeight, tagX + nameWidth - radius, tagY + tagHeight);
        ctx.lineTo(tagX + radius, tagY + tagHeight);
        ctx.quadraticCurveTo(tagX, tagY + tagHeight, tagX, tagY + tagHeight - radius);
        ctx.lineTo(tagX, tagY + radius);
        ctx.quadraticCurveTo(tagX, tagY, tagX + radius, tagY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Reset shadow
        ctx.shadowBlur = 0;
      }

      // Text with slight shadow for better readability
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;

      ctx.fillStyle = '#222';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(horse.name, x, tagY + tagHeight/2);

      // Reset shadow
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      ctx.restore();

      // Speed indicator (dust particles) - only draw when performance allows
      if (perfSettings.drawParticles && horse.speed > 3 && frameCount % 5 === 0) {
        for (let i = 0; i < 1; i++) {
          ctx.fillStyle = `rgba(139, 115, 85, ${0.4 - i * 0.1})`;
          ctx.beginPath();
          const dustX = x - (50 * scale) - i * 12 - (frameCount % 20);
          const dustY = y + (15 * scale) + Math.sin(frameCount * 0.2 + i) * 4;
          const dustSize = (5 - i) * scale;
          ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawObstacle(obstacle) {
      const x = obstacle.x;
      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;
      const centerY = trackY + trackHeight * 0.5;

      // Draw obstacle as a hurdle
      ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      ctx.fillRect(x - 5, centerY - 40, 10, 80);

      // Hurdle bar
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(x - 30, centerY - 30, 60, 10);
      ctx.fillRect(x - 30, centerY + 20, 60, 10);

      // Warning sign
      ctx.fillStyle = '#ffff00';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö†Ô∏è', x, centerY - 50);
    }

    // ===== Create Entities =====
    function createClouds() {
      clouds = [];
      for (let i = 0; i < 3; i++) {
        clouds.push({
          x: Math.random() * canvas.width,
          y: 50 + Math.random() * 150,
          speed: 0.1 + Math.random() * 0.3
        });
      }
    }

    function createTrees() {
      trees = [];
      // Th√™m c√¢y c·ªëi ·ªü ph√≠a tr√™n ƒë∆∞·ªùng ƒëua (v√πng grass)
      for (let i = 0; i < 8; i++) {
        trees.push({
          x: Math.random() * canvas.width * 2, // Ph√¢n b·ªë r·ªông h∆°n
          y: canvas.height * 0.28 // V√πng grass ph√≠a tr√™n track
        });
      }
      // Th√™m c√¢y ·ªü v√πng sky/grass ph√≠a tr√™n
      for (let i = 0; i < 5; i++) {
        trees.push({
          x: Math.random() * canvas.width * 2,
          y: canvas.height * 0.15 + Math.random() * canvas.height * 0.08
        });
      }
    }

    // Update performance settings based on player count
    function updatePerformanceSettings(playerCount) {
      if (playerCount > 50) {
        perfSettings = {
          drawShadows: false,
          drawParticles: false,
          drawComplexAura: false,
          drawTrees: false,
          drawClouds: false,
          simplifiedNameTags: true
        };
        targetFrameTime = 1000 / 30; // 30 FPS for 50+ players
      } else if (playerCount > 30) {
        perfSettings = {
          drawShadows: false,
          drawParticles: false,
          drawComplexAura: false,
          drawTrees: true,
          drawClouds: true,
          simplifiedNameTags: true
        };
        targetFrameTime = 1000 / 45; // 45 FPS for 30-50 players
      } else if (playerCount > 20) {
        perfSettings = {
          drawShadows: false,
          drawParticles: false,
          drawComplexAura: false,
          drawTrees: true,
          drawClouds: true,
          simplifiedNameTags: true
        };
        targetFrameTime = 1000 / 60; // 60 FPS
      } else if (playerCount > 10) {
        perfSettings = {
          drawShadows: false,
          drawParticles: false,
          drawComplexAura: true,
          drawTrees: true,
          drawClouds: true,
          simplifiedNameTags: false
        };
        targetFrameTime = 1000 / 60; // 60 FPS
      } else {
        perfSettings = {
          drawShadows: false,
          drawParticles: true,
          drawComplexAura: true,
          drawTrees: true,
          drawClouds: true,
          simplifiedNameTags: false
        };
        targetFrameTime = 1000 / 60; // 60 FPS
      }
    }

    function createHorses() {
      // B·∫£ng m√†u ƒë·∫πp cho vi·ªÅn name tag v√† c√°c hi·ªáu ·ª©ng
      const borderColors = [
        '#FF1744', '#D500F9', '#2979FF', '#00E676', '#FFEA00',
        '#FF6D00', '#00BFA5', '#DD2C00', '#AA00FF', '#0091EA',
        '#76FF03', '#FF9100', '#E040FB', '#18FFFF', '#FFC400',
        '#FF3D00', '#651FFF', '#00B0FF', '#C6FF00', '#FF6E40',
        '#7C4DFF', '#00E5FF', '#AEEA00', '#FF9E80', '#B388FF',
        '#82B1FF', '#B9F6CA', '#FFD180', '#FF80AB', '#84FFFF'
      ];

      // C√°c gi√° tr·ªã hue-rotate t·ªët cho m√†u s·∫Øc ƒë·∫πp v√† ph√¢n bi·ªát r√µ
      const niceHues = [
        0,    // N√¢u g·ªëc
        30,   // N√¢u cam
        60,   // V√†ng n√¢u
        90,   // V√†ng xanh
        120,  // Xanh l√°
        150,  // Xanh l√° nh·∫°t
        180,  // Xanh d∆∞∆°ng
        210,  // Xanh d∆∞∆°ng ƒë·∫≠m
        240,  // T√≠m xanh
        270,  // T√≠m
        300,  // T√≠m h·ªìng
        330,  // H·ªìng ƒë·ªè
        45,   // Cam v√†ng
        135,  // Xanh l√° s√°ng
        225,  // Xanh t√≠m
        315   // H·ªìng
      ];

      horses = [];
      horseCanvasCache.clear(); // Clear cache for new race

      players.forEach((name, idx) => {
        const borderColor = borderColors[idx % borderColors.length];

        // Ch·ªçn hue rotation theo th·ª© t·ª± t·ª´ b·∫£ng m√†u ƒë·∫πp, sau ƒë√≥ random
        let hueRotate;
        if (idx < niceHues.length) {
          hueRotate = niceHues[idx];
        } else {
          // N·∫øu nhi·ªÅu ng∆∞·ªùi ch∆°i h∆°n b·∫£ng m√†u, random nh∆∞ng tr√°nh tr√πng
          hueRotate = (idx * 37) % 360; // 37 l√† s·ªë nguy√™n t·ªë ƒë·ªÉ t·∫°o ph√¢n b·ªë ƒë·ªÅu
        }

        // Random depth offset to create visual separation (spread horses vertically)
        const depthOffset = (Math.random() - 0.5) * canvas.height * 0.4;

        horses.push({
          name,
          color: borderColor, // D√πng cho vi·ªÅn name tag
          hueRotate, // For color variation in GIF
          depthOffset, // Vertical position variation
          position: 150, // Start further right so horses are visible
          speed: rand(1.5, 2.5),
          targetSpeed: rand(1.5, 2.5),
          stamina: 1.0,
          burstCD: 0,
          slipCD: 0,
          scriptedBoostUntil: 0,
          scriptedFatigueUntil: 0,
          isWinner: false
        });
      });

      // Update performance settings based on player count
      updatePerformanceSettings(players.length);
    }

    function createObstacles() {
      obstacles = [];
      // Scale obstacle count based on player count for better performance
      let count = 3;
      if (horses.length > 50) count = 1; // Minimal obstacles for many players
      else if (horses.length > 20) count = 2;

      for (let i = 0; i < count; i++) {
        obstacles.push({
          x: 200 + i * (canvas.width - 300) / Math.max(1, count),
          active: false,
          used: false,
          cooldown: 0
        });
      }
    }

    // ===== Game Logic =====
    function tryScheduleObstacle() {
      const elapsed = (Date.now() - raceStartTime) / 1000;
      const remaining = Math.max(0, raceDuration - elapsed);

      const elimLimit = Math.floor(totalPlayers * maxEliminationPercent);
      const canEliminateMore = eliminatedHorses.length < elimLimit;

      if (!canEliminateMore) return;
      if (remaining <= 4) return;
      if (obstacleInProgress) return;
      if (Date.now() < nextObstacleAt) return;

      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (!alive.length) return;

      const sorted = [...alive].sort((a,b) => b.position - a.position);
      const topK = sorted.slice(0, Math.max(2, Math.floor(sorted.length * 0.5)));
      const targetHorse = pick(topK);

      // Find nearest unused obstacle
      let best = null;
      let bestDist = Infinity;
      for (const ob of obstacles) {
        if (ob.used || ob.cooldown > 0) continue;
        const dist = Math.abs(targetHorse.position - ob.x);
        if (dist < bestDist && dist < 150) {
          bestDist = dist;
          best = ob;
        }
      }

      if (best) {
        best.active = true;
        best.targetHorse = targetHorse;
        obstacleInProgress = true;
      }

      nextObstacleAt = Date.now() + Math.floor(rand(OBSTACLE_GAP_MIN, OBSTACLE_GAP_MAX));
    }

    function scheduleOvertakeIfNeeded() {
      if (Date.now() < nextOvertakeAt) return;
      nextOvertakeAt = Date.now() + Math.floor(rand(OVERTAKE_GAP_MIN, OVERTAKE_GAP_MAX));

      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (alive.length < 2) return;

      const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));
      const candidates = alive.filter(h => h.name !== leader.name);
      const chosen = pick(candidates);

      const now = Date.now();
      chosen.scriptedBoostUntil = now + 2200 + Math.floor(Math.random() * 400);
      chosen.scriptedFatigueUntil = chosen.scriptedBoostUntil + 1600 + Math.floor(Math.random() * 500);
    }

    function updateHorses() {
      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (!alive.length) return;

      const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));

      horses.forEach(horse => {
        if (eliminatedHorses.includes(horse.name)) return;

        // Don't update regular horses in cinematic mode
        if (mode === MODE.WIN_CINEMATIC && !horse.isWinner) return;

        horse.burstCD = Math.max(0, horse.burstCD - 1);
        horse.slipCD = Math.max(0, horse.slipCD - 1);

        const drain = Math.max(0, horse.speed - 2.5) * 0.003;
        const regen = Math.max(0, 2.8 - horse.speed) * 0.002;
        horse.stamina = clamp(horse.stamina - drain + regen, 0, 1);

        const distFromLeader = Math.abs(horse.position - leader.position);
        if (distFromLeader > 80) horse.targetSpeed = Math.max(horse.targetSpeed, 3.0);
        if (distFromLeader < 20) horse.targetSpeed = Math.min(horse.targetSpeed, 2.0);

        horse.targetSpeed = clamp(horse.targetSpeed + (Math.random() - 0.5) * 0.1, 1.5, 4.5);

        const now = Date.now();
        if (now < horse.scriptedBoostUntil) horse.targetSpeed = Math.max(horse.targetSpeed, 5.0);
        else if (now < horse.scriptedFatigueUntil) horse.targetSpeed = Math.min(horse.targetSpeed, 2.0);

        if (horse.burstCD === 0 && horse.stamina > 0.35 && Math.random() < 0.008) {
          horse.targetSpeed = 4.5 + Math.random() * 1.5;
          horse.stamina = Math.max(0, horse.stamina - 0.22);
          horse.burstCD = 95;
        }
        if (horse.slipCD === 0 && horse.stamina < 0.25 && Math.random() < 0.006) {
          horse.targetSpeed = 1.5 + Math.random() * 0.8;
          horse.slipCD = 85;
        }

        horse.speed += (horse.targetSpeed - horse.speed) * 0.08;
        horse.position += horse.speed;
      });
    }

    function updateObstacles() {
      obstacles.forEach(ob => {
        if (ob.cooldown > 0) ob.cooldown--;

        if (ob.active && ob.targetHorse) {
          const horse = ob.targetHorse;
          if (eliminatedHorses.includes(horse.name)) {
            ob.active = false;
            ob.used = true;
            ob.cooldown = 180;
            obstacleInProgress = false;
            return;
          }

          if (Math.abs(horse.position - ob.x) < 30) {
            eliminatedHorses.push(horse.name);

            ob.active = false;
            ob.used = true;
            ob.cooldown = 180;
            obstacleInProgress = false;
          }
        }
      });
    }

    function checkWinner() {
      const elapsed = (Date.now() - raceStartTime) / 1000;
      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));

      // Only declare winner when time is up
      if (elapsed >= raceDuration && !winner) {
        const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));
        setWinner(leader.name, `‚è∞ H·∫øt gi·ªù! ${leader.name} v·ªÅ ƒë√≠ch!`);
      }
    }

    function setWinner(name, reasonText) {
      if (winner) return;
      winner = name;

      const wh = horses.find(h => h.name === name);
      if (!wh) return;

      wh.isWinner = true;

      // Don't reset position - let winner sprint from current position!
      // wh.position stays as-is in the pack

      // Start cinematic
      mode = MODE.WIN_CINEMATIC;
      winCine.active = true;
      winCine.horse = wh;
      winCine.phase = 'SPRINT';
      winCine.startAt = Date.now();
      winCine.finishAt = 0;

      // Stop obstacles
      obstacles.forEach(ob => {
        ob.isCatching = false;
      });
      obstacleInProgress = false;
    }

    function updateWinnerCinematic(time) {
      if (!winCine.active || !winCine.horse) return;
      const wh = winCine.horse;

      if (winCine.phase === 'SPRINT') {
        // Winner EXPLODES forward from the pack with MASSIVE speed boost!
        wh.targetSpeed = 20.0; // Super fast for dramatic burst
        wh.speed += (wh.targetSpeed - wh.speed) * 0.25;
        wh.position += wh.speed;

        // Stop other horses completely so winner stands out
        horses.forEach(h => {
          if (!h.isWinner && !eliminatedHorses.includes(h.name)) {
            h.targetSpeed = 0; // Stop them completely
            h.speed += (h.targetSpeed - h.speed) * 0.3;
            // Don't move other horses at all during cinematic
          }
        });

        // Camera follows winner smoothly as they sprint ahead
        const targetCameraOffset = wh.position - canvas.width * 0.5; // Keep winner centered
        cameraOffset += (targetCameraOffset - cameraOffset) * 0.15; // Smooth camera

        // Extended sprint duration so players can see the dramatic finish!
        const sprintDuration = (Date.now() - winCine.startAt) / 1000;
        
        // Check if winner has sprinted long enough
        if (sprintDuration >= 4.0) {
          winCine.phase = 'CELEBRATE';
          winCine.finishAt = Date.now();
        }
      }

      if (winCine.phase === 'CELEBRATE') {
        const elapsed = Date.now() - winCine.finishAt;

        // Continue camera movement slowly
        cameraOffset += 0.5;

        if (elapsed > 2500) {
          winCine.phase = 'SHOW';
          announceWinnerUI();
        }
      }
    }

    function announceWinnerUI() {
      mode = MODE.ENDED;
      winCine.active = false;

      winnerNameEl.textContent = winner;
      winnerPanel.classList.remove('hidden');
      setTimeout(() => winnerPanel.classList.add('show'), 100);
      createConfetti();

      // Stop racing music and play victory music
      stopMusic();
      playVictoryMusic();
    }

    // ===== Confetti =====
    const confettiParticles = [];
    function createConfetti() {
      const colors = ['#ff6b81', '#70a1ff', '#feca57', '#48dbfb', '#ff6348'];
      // Reduce confetti count for better performance with many players
      const count = horses.length > 50 ? 10 : (horses.length > 20 ? 20 : 30);
      for (let i = 0; i < count; i++) {
        confettiParticles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 5 + Math.random() * 10,
          speedY: 2 + Math.random() * 3,
          speedX: (Math.random() - 0.5) * 2,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.2
        });
      }
    }

    function drawConfetti() {
      confettiParticles.forEach((p, index) => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        ctx.restore();

        p.y += p.speedY;
        p.x += p.speedX;
        p.rotation += p.rotationSpeed;

        if (p.y > canvas.height) {
          confettiParticles.splice(index, 1);
        }
      });
    }

    // ===== Main Game Loop =====
    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);

      // Frame rate limiting for better performance with many players
      const elapsed = currentTime - lastFrameTime;
      if (elapsed < targetFrameTime) {
        return; // Skip this frame to maintain target FPS
      }
      lastFrameTime = currentTime - (elapsed % targetFrameTime);

      frameCount++;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      drawSky();

      // Update and draw clouds (highly optimized - skip if many players)
      if (perfSettings.drawClouds) {
        if (frameCount % 5 === 0) {
          clouds.forEach(cloud => {
            cloud.x -= cloud.speed;
            if (cloud.x - cameraOffset * 0.3 < -100) cloud.x = canvas.width + cameraOffset * 0.3 + 100;
            drawCloud(cloud);
          });
        } else {
          clouds.forEach(cloud => drawCloud(cloud));
        }
      }

      drawGround();

      // Draw trees (optimized - skip if many players or off screen)
      if (perfSettings.drawTrees) {
        trees.forEach(tree => {
          const treeScreenX = tree.x - cameraOffset * 0.5;
          if (treeScreenX < -100 || treeScreenX > canvas.width + 100) {
            if (tree.x - cameraOffset * 0.5 < -50) {
              tree.x = canvas.width + cameraOffset * 0.5 + 50;
            }
            return;
          }
          drawTree(tree);
        });
      }

      // Draw finish line only in cinematic mode
      if (mode === MODE.WIN_CINEMATIC) {
        drawFinishLine();
      }

      if (mode === MODE.WIN_CINEMATIC) {
        // Update time display
        const elapsed = (Date.now() - raceStartTime) / 1000;
        const remaining = Math.max(0, raceDuration - elapsed);
        const timeEl = document.getElementById('timeRemaining');
        if (timeEl) timeEl.textContent = `‚è±Ô∏è ${Math.ceil(remaining)}s`;

        // Update winner cinematic (this updates winner horse and camera)
        updateWinnerCinematic(Date.now() * 0.001);

        // Draw horses sorted by position (back to front for depth effect)
        // Only draw horses near camera to reduce lag with many players
        if (frameCount - lastSortFrame > 5 || lastSortFrame === -1) {
          sortedHorsesCache = [...horses]
            .filter(h => {
              // Always draw winner, only draw others if close to camera view
              if (h.isWinner) return true;
              const screenX = h.position - cameraOffset;
              return screenX > -300 && screenX < canvas.width + 300;
            })
            .sort((a, b) => a.position - b.position);
          lastSortFrame = frameCount;
        }
        sortedHorsesCache.forEach((horse, idx) => drawHorse(horse, idx));

        return;
      }

      if (mode === MODE.RACING) {
        // Update time
        const elapsed = (Date.now() - raceStartTime) / 1000;
        const remaining = Math.max(0, raceDuration - elapsed);
        const timeEl = document.getElementById('timeRemaining');
        if (timeEl) timeEl.textContent = `‚è±Ô∏è ${Math.ceil(remaining)}s`;

        // Update game logic
        updateHorses();
        // updateObstacles(); // V√¥ hi·ªáu h√≥a obstacles
        // tryScheduleObstacle(); // V√¥ hi·ªáu h√≥a obstacles
        scheduleOvertakeIfNeeded();
        checkWinner();

        // Update camera offset to keep horses on left side of screen
        const aliveHorses = horses.filter(h => !eliminatedHorses.includes(h.name));
        if (aliveHorses.length > 0) {
          // Calculate average position of all alive horses
          const avgPosition = aliveHorses.reduce((sum, h) => sum + h.position, 0) / aliveHorses.length;
          // Camera follows the pack to keep them at 20% of screen (left-center for better view)
          const targetCameraOffset = avgPosition - canvas.width * 0.2;
          // Smooth camera movement
          cameraOffset += (targetCameraOffset - cameraOffset) * 0.15;
        }

        // Draw obstacles - DISABLED (h√†ng r√†o ƒë√£ b·ªã x√≥a)
        // obstacles.forEach(ob => {
        //   if (!ob.used) drawObstacle(ob);
        // });
      }

      // Draw horses sorted by position (back to front for depth effect)
      // Cache sorting to improve performance - interval based on player count
      const sortInterval = horses.length > 50 ? 30 : (horses.length > 20 ? 20 : 15);
      if (frameCount - lastSortFrame > sortInterval || lastSortFrame === -1 || sortedHorsesCache.length === 0) {
        sortedHorsesCache = [...horses].sort((a, b) => a.position - b.position);
        lastSortFrame = frameCount;
      }
      
      // In cinematic mode, only draw winner and closest horses for performance
      if (mode === MODE.WIN_CINEMATIC) {
        // Find winner and 2-3 closest horses
        const winnerHorse = sortedHorsesCache.find(h => h.isWinner);
        const closestHorses = sortedHorsesCache
          .filter(h => !h.isWinner && !eliminatedHorses.includes(h.name))
          .sort((a, b) => Math.abs(b.position - winnerHorse.position) - Math.abs(a.position - winnerHorse.position))
          .slice(0, Math.min(3, totalPlayers - 1)); // Max 3 background horses
        
        // Draw background horses first (faded)
        closestHorses.forEach((horse, idx) => {
          ctx.globalAlpha = 0.3; // Make them very faded
          drawHorse(horse, idx);
          ctx.globalAlpha = 1.0;
        });
        
        // Draw winner on top (full opacity)
        if (winnerHorse) {
          drawHorse(winnerHorse, sortedHorsesCache.indexOf(winnerHorse));
        }
      } else {
        // Normal mode: draw all horses
        sortedHorsesCache.forEach((horse, idx) => drawHorse(horse, idx));
      }

      // Draw confetti
      if (confettiParticles.length > 0) {
        drawConfetti();
      }
    }

    // ===== Reset / Start =====
    function resetRace() {
      winner = null;
      eliminatedHorses = [];
      horses = [];
      obstacles = [];
      confettiParticles.length = 0;
      frameCount = 0;
      cameraOffset = -100; // Negative offset to show horses at race start
      sortedHorsesCache = [];
      lastSortFrame = -1;

      winCine = { active: false, horse: null, phase: 'SPRINT', startAt: 0, finishAt: 0 };

      nextObstacleAt = Date.now() + 2500;
      obstacleInProgress = false;
      nextOvertakeAt = Date.now() + 1500; // Start boost events earlier
    }

    function startRace() {
      resetRace();

      totalPlayers = players.length;
      createClouds();
      createTrees();
      createHorses();
      createObstacles();

      raceStartTime = Date.now();
      mode = MODE.RACING;

      raceInfo.style.display = 'block';

      // Start background music
      playRandomMusic();
    }

    // ===== Utility Functions =====
    // Fisher-Yates shuffle algorithm
    function shuffleArray(array) {
      const arr = [...array]; // Create a copy
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ===== Event Listeners =====
    playerInput.addEventListener('input', () => {
      const text = playerInput.value.trim();
      players = text ? text.split('\n').map(s => s.trim()).filter(Boolean) : [];
      startBtn.disabled = players.length < 2;
    });

    // Random button - shuffle player list
    randomBtn.addEventListener('click', () => {
      const text = playerInput.value.trim();
      if (!text) {
        alert('Vui l√≤ng nh·∫≠p danh s√°ch ng∆∞·ªùi ch∆°i tr∆∞·ªõc!');
        return;
      }

      const playerList = text.split('\n').map(s => s.trim()).filter(Boolean);
      if (playerList.length < 2) {
        alert('C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ random!');
        return;
      }

      // Shuffle the list
      const shuffled = shuffleArray(playerList);
      playerInput.value = shuffled.join('\n');

      // Update players array
      players = shuffled;

      // Visual feedback
      randomBtn.textContent = '‚ú® ƒê√£ Random!';
      setTimeout(() => {
        randomBtn.textContent = 'üîÄ Random Danh S√°ch';
      }, 1000);
    });

    startBtn.addEventListener('click', () => {
      const text = playerInput.value.trim();
      if (!text) return alert('Vui l√≤ng nh·∫≠p danh s√°ch ng∆∞·ªùi ch∆°i!');
      players = text.split('\n').map(s => s.trim()).filter(Boolean);
      if (players.length < 2) return alert('C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i!');

      raceDuration = Math.max(1, parseInt(raceDurationInput.value, 10) || 30);

      setupPanel.classList.add('hidden');
      const timeEl = document.getElementById('timeRemaining');
      if (timeEl) timeEl.textContent = `‚è±Ô∏è ${raceDuration}s`;

      startRace();
    });

    restartBtn.addEventListener('click', () => location.reload());

    // ===== Initialize =====
    createClouds();
    createTrees();
    gameLoop();
  </script>
</body>
</html>
