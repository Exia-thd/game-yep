<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üê¥ ƒêua Ng·ª±a B·∫Øt C√∫p</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Sriracha&family=Quicksand:wght@600;700&display=swap');
    *{margin:0;padding:0;box-sizing:border-box;}
    body{
      font-family:'Quicksand',sans-serif;
      overflow:hidden;
      background:linear-gradient(135deg,#87CEEB 0%,#98D8E8 50%,#B0E8F5 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
    }
    #gameCanvas{
      display:block;
      background:linear-gradient(to bottom, #87CEEB 0%, #f0f8ff 30%, #90EE90 100%);
      border:5px solid #fff;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
      border-radius:15px;
      max-width:95vw;
      max-height:90vh;
    }

    .ui-overlay{position:fixed;inset:0;pointer-events:none;z-index:10;}

    .setup-panel{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      background:linear-gradient(145deg,rgba(255,255,255,0.95),rgba(255,248,240,0.95));
      padding:40px;border-radius:30px;
      box-shadow:0 20px 80px rgba(0,0,0,0.4), 0 0 40px rgba(245,87,108,0.3), inset 0 1px 0 rgba(255,255,255,0.8);
      pointer-events:all;max-width:520px;width:90%;
      max-height:85vh;overflow-y:auto;
      backdrop-filter:blur(20px);border:3px solid rgba(255,255,255,0.8);
      display:flex;flex-direction:column;
      animation:panelFloat 3s ease-in-out infinite;
    }
    @keyframes panelFloat{
      0%, 100%{transform:translate(-50%,-50%) translateY(0px);}
      50%{transform:translate(-50%,-50%) translateY(-5px);}
    }
    .setup-panel h1{
      font-family:'Sriracha',cursive;color:#f5576c;font-size:42px;text-align:center;
      margin-bottom:10px;text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 20px rgba(245,87,108,0.5);letter-spacing:1px;
      animation:titleGlow 2s ease-in-out infinite;
    }
    @keyframes titleGlow{
      0%, 100%{text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 20px rgba(245,87,108,0.5);}
      50%{text-shadow:3px 3px 0 rgba(255,215,0,0.3), 0 0 30px rgba(245,87,108,0.8), 0 0 40px rgba(245,87,108,0.4);}
    }
    .setup-panel p{text-align:center;color:#666;margin-bottom:22px;font-size:16px;font-weight:600;}

    .player-input-area{margin-bottom:18px;flex-shrink:0;}
    .player-input-area label{display:block;color:#f5576c;font-weight:700;margin-bottom:10px;font-size:16px;}
    #playerInput{
      width:100%;padding:15px;border:3px solid #f5576c;border-radius:15px;
      font-size:16px;font-family:'Quicksand',sans-serif;font-weight:600;
      background:#fff;min-height:150px;resize:vertical;line-height:1.6;
      transition:all .25s ease;
    }
    #playerInput:focus{
      outline:none;border-color:#ffd700;box-shadow:0 0 0 3px rgba(255,215,0,0.2);
      transform:translateY(-2px);
    }

    .btn{
      width:100%;padding:18px;font-size:20px;font-weight:700;font-family:'Quicksand',sans-serif;
      border:none;border-radius:15px;cursor:pointer;transition:all .25s ease;
      letter-spacing:0.5px;box-shadow:0 6px 20px rgba(0,0,0,0.2);
      pointer-events:all;
      display:flex;align-items:center;justify-content:center;
      text-align:center;
    }
    .btn-start{background:linear-gradient(135deg,#f093fb 0%,#f5576c 50%,#ffd700 100%);color:#fff;margin-top:10px;
      background-size:200% 100%;animation:gradientSlide 3s ease infinite;position:relative;overflow:hidden;}
    .btn-start::before{content:'';position:absolute;top:50%;left:50%;width:0;height:0;
      background:rgba(255,255,255,0.3);border-radius:50%;transform:translate(-50%,-50%);
      transition:width 0.6s, height 0.6s;}
    .btn-start:hover:not(:disabled)::before{width:300%;height:300%;}
    .btn-start:hover:not(:disabled){transform:translateY(-3px) scale(1.02);box-shadow:0 15px 40px rgba(245,87,108,0.6), 0 0 20px rgba(255,215,0,0.4);}
    @keyframes gradientSlide{
      0%, 100%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
    }
    .btn-start:disabled{opacity:.5;cursor:not-allowed;}

    .race-info{
      position:fixed;top:30px;left:50%;transform:translateX(-50%);
      background:linear-gradient(145deg,rgba(255,255,255,0.95),rgba(255,248,240,0.95));
      padding:18px 36px;border-radius:20px;
      box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 30px rgba(245,87,108,0.3);
      font-family:'Sriracha',cursive;font-size:28px;color:#f5576c;text-align:center;
      border:3px solid rgba(255,255,255,0.8);backdrop-filter:blur(20px);
      display:none;pointer-events:all;z-index:9998;
      animation:infoPulse 2s ease-in-out infinite;
    }
    @keyframes infoPulse{
      0%, 100%{box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 30px rgba(245,87,108,0.3);}
      50%{box-shadow:0 10px 40px rgba(0,0,0,0.4), 0 0 40px rgba(245,87,108,0.6), 0 0 60px rgba(245,87,108,0.2);}
    }

    .winner-announcement{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);
      background:linear-gradient(145deg,#ffd700,#ffed4e,#ffd700);
      background-size:200% 200%;animation:rainbowShift 3s ease infinite;
      padding:60px;border-radius:30px;
      box-shadow:0 30px 100px rgba(0,0,0,0.5), 0 0 60px rgba(255,215,0,0.8), 0 0 100px rgba(255,215,0,0.4);
      text-align:center;border:5px solid #fff;
      z-index:9999;transition:transform .5s cubic-bezier(0.68,-0.55,0.265,1.55);
      pointer-events:all;
    }
    @keyframes rainbowShift{
      0%, 100%{background-position:0% 50%;filter:hue-rotate(0deg);}
      50%{background-position:100% 50%;filter:hue-rotate(20deg);}
    }
    .winner-announcement.show{transform:translate(-50%,-50%) scale(1);}
    .winner-announcement h2{
      font-family:'Sriracha',cursive;font-size:48px;color:#d63031;margin-bottom:18px;
      text-shadow:3px 3px 0 rgba(0,0,0,0.1);animation:pulse 1s infinite;
    }
    .winner-announcement .winner-name{
      font-size:56px;font-weight:700;color:#2d3436;margin:20px 0;
      text-shadow:2px 2px 0 rgba(255,255,255,0.8);word-break:break-word;
    }
    .winner-announcement .trophy{font-size:100px;animation:bounce .8s infinite;
      filter:drop-shadow(0 10px 20px rgba(255,215,0,0.6));}
    @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
    @keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-20px)}}

    .btn-restart{background:linear-gradient(135deg,#00b894,#00cec9);color:#fff;margin-top:26px;}
    .btn-restart:hover{transform:translateY(-3px);box-shadow:0 10px 30px rgba(0,184,148,0.4);}
    .hidden{display:none !important;}

    .event-log{
      position:fixed;top:120px;right:20px;width:380px;max-height:560px;
      background:rgba(255,255,255,0.98);border-radius:20px;padding:20px;
      box-shadow:0 10px 40px rgba(0,0,0,0.4);border:3px solid rgba(255,255,255,0.8);
      backdrop-filter:blur(10px);display:none;overflow:auto;pointer-events:all;z-index:9999;
      transition:opacity 0.5s ease;
      scroll-behavior:smooth;
    }
    .event-log.hidden{
      opacity:0;
      pointer-events:none;
    }
    .event-log h3{font-family:'Sriracha',cursive;color:#f5576c;font-size:28px;margin:0 0 15px 0;text-align:center;}
    .event-item{padding:14px;margin-bottom:10px;border-radius:12px;font-size:18px;font-weight:700;line-height:1.5;animation:slideInRight .25s ease;
      text-shadow:0 1px 2px rgba(0,0,0,0.1);}
    @keyframes slideInRight{from{opacity:0;transform:translateX(18px);}to{opacity:1;transform:translateX(0);}}
    .event-caught{background:linear-gradient(135deg,#ff4757,#ff6b6b,#ff8787);color:#fff;box-shadow:0 4px 15px rgba(255,71,87,0.6);
      border:2px solid rgba(255,255,255,0.5);font-size:20px;animation:eventPulse 1.5s ease infinite;}
    .event-eliminated{background:linear-gradient(135deg,#ffa502,#ff9ff3,#f368e0);color:#fff;box-shadow:0 4px 15px rgba(255,165,2,0.6);
      border:2px solid rgba(255,255,255,0.5);text-shadow:1px 1px 2px rgba(0,0,0,0.3);}
    .event-info{background:linear-gradient(135deg,#0abde3,#48dbfb,#00d2d3);color:#fff;box-shadow:0 4px 15px rgba(10,189,227,0.6);
      border:2px solid rgba(255,255,255,0.4);}
    @keyframes eventPulse{0%,100%{transform:scale(1);}50%{transform:scale(1.02);}}
  </style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay">
    <div id="setupPanel" class="setup-panel">
      <h1>üê¥ ƒêua Ng·ª±a B·∫Øt C√∫p</h1>
      <p>Nh·∫≠p danh s√°ch ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc ƒëua!</p>

      <div class="player-input-area">
        <label for="playerInput">Danh s√°ch ng∆∞·ªùi ch∆°i (m·ªói d√≤ng 1 ng∆∞·ªùi):</label>
        <textarea id="playerInput" placeholder="Nguy·ªÖn VƒÉn A
Tr·∫ßn Th·ªã B
L√™ VƒÉn C"></textarea>
      </div>

      <div class="player-input-area">
        <label for="raceDuration">‚è±Ô∏è Th·ªùi gian ƒëua (gi√¢y):</label>
        <input type="number" id="raceDuration" min="1" value="30"
          style="width:100%; padding:15px; border:3px solid #f5576c; border-radius:15px;
                 font-size:16px; font-family:'Quicksand',sans-serif; font-weight:600;">
        <p style="font-size:14px;color:#666;margin-top:8px;">T·ªëi thi·ªÉu 1 gi√¢y</p>
      </div>

      <button class="btn btn-start" id="startBtn" disabled>üèÅ B·∫Øt ƒê·∫ßu ƒêua!</button>
    </div>

    <div id="raceInfo" class="race-info">
      üèÅ Cu·ªôc ƒëua ƒëang di·ªÖn ra! üèÅ<br>
      <span id="timeRemaining" style="font-size:20px;color:#ff6b6b;">‚è±Ô∏è 30s</span>
    </div>

    <div id="winnerPanel" class="winner-announcement hidden">
      <div class="trophy">üèÜ</div>
      <h2>üéâ Ng∆∞·ªùi Th·∫Øng Cu·ªôc üéâ</h2>
      <div class="winner-name" id="winnerName"></div>
      <button class="btn btn-restart" id="restartBtn">üîÑ Ch∆°i L·∫°i</button>
    </div>

    <div id="eventLog" class="event-log">
      <h3>üìú Nh·∫≠t K√Ω S·ª± Ki·ªán</h3>
      <div id="eventList"></div>
    </div>
  </div>

  <script>
    'use strict';

    // ===== Canvas Setup =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size
    function resizeCanvas() {
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = window.innerHeight * 0.85;
      const aspectRatio = 16 / 9;

      let width = maxWidth;
      let height = width / aspectRatio;

      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
      }

      canvas.width = Math.min(1400, width);
      canvas.height = Math.min(800, height);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ===== Helpers =====
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand  = (a, b) => a + Math.random() * (b - a);
    const pick  = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // Helper to make color darker/lighter
    function shadeColor(color, percent) {
      let R = parseInt(color.substring(1,3), 16);
      let G = parseInt(color.substring(3,5), 16);
      let B = parseInt(color.substring(5,7), 16);

      R = Math.max(0, Math.min(255, R + percent));
      G = Math.max(0, Math.min(255, G + percent));
      B = Math.max(0, Math.min(255, B + percent));

      const RR = R.toString(16).padStart(2, '0');
      const GG = G.toString(16).padStart(2, '0');
      const BB = B.toString(16).padStart(2, '0');

      return "#" + RR + GG + BB;
    }

    // ===== UI =====
    const setupPanel = document.getElementById('setupPanel');
    const playerInput = document.getElementById('playerInput');
    const startBtn = document.getElementById('startBtn');
    const raceDurationInput = document.getElementById('raceDuration');
    const raceInfo = document.getElementById('raceInfo');
    const winnerPanel = document.getElementById('winnerPanel');
    const winnerNameEl = document.getElementById('winnerName');
    const eventLog = document.getElementById('eventLog');
    const eventListEl = document.getElementById('eventList');
    const restartBtn = document.getElementById('restartBtn');

    function addEventLog(msg, type='info') {
      const el = document.createElement('div');
      el.className = `event-item event-${type}`;

      // Add timestamp and icon for clarity
      const elapsed = mode === MODE.RACING ? Math.floor((Date.now() - raceStartTime) / 1000) : 0;
      const timeStr = elapsed > 0 ? `[${elapsed}s] ` : '';
      const icon = type === 'caught' ? 'üèÜ ' : type === 'eliminated' ? 'üí• ' : '‚ÑπÔ∏è ';

      el.textContent = timeStr + icon + msg;
      eventListEl.insertBefore(el, eventListEl.firstChild);
      while (eventListEl.children.length > 10) eventListEl.removeChild(eventListEl.lastChild);
    }

    // ===== State =====
    let players = [];
    let horses = [];
    let clouds = [];
    let trees = [];
    let obstacles = [];

    let eliminatedHorses = [];
    let totalPlayers = 0;

    // Horse sorting cache
    let sortedHorsesCache = [];
    let lastSortFrame = -1;

    // Load horse image
    const horseImg = new Image();
    horseImg.src = 'horse.gif';
    let horseImgLoaded = false;
    horseImg.onload = () => {
      horseImgLoaded = true;
    };

    let raceDuration = 30;
    let raceStartTime = 0;
    let winner = null;

    const MODE = { SETUP:'SETUP', RACING:'RACING', WIN_CINEMATIC:'WIN_CINEMATIC', ENDED:'ENDED' };
    let mode = MODE.SETUP;

    // ===== Background Music =====
    let backgroundMusic = new Audio();
    backgroundMusic.volume = 1.0;

    const musicTracks = [
      'Music/edm-gaming-music-335408.mp3',
      'Music/level-up-energetic-gaming-rock-music-251284.mp3',
      'Music/victory-awaits-in-the-gaming-universe_astronaut-265184.mp3',
      'Music/gaming-game-minecraft-background-music-372242.mp3',
      'Music/retro-game-402454.mp3'
    ];

    let currentTrackIndex = -1;

    function playRandomMusic() {
      if (musicTracks.length === 0) return;
      let newIndex;
      do {
        newIndex = Math.floor(Math.random() * musicTracks.length);
      } while (newIndex === currentTrackIndex && musicTracks.length > 1);

      currentTrackIndex = newIndex;
      backgroundMusic.src = musicTracks[currentTrackIndex];
      backgroundMusic.play().catch(err => console.log('Music play failed:', err));
    }

    function stopMusic() {
      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;
    }

    function playVictoryMusic() {
      backgroundMusic.src = 'Music/gaming-game-minecraft-background-music-387000.mp3';
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(err => console.log('Victory music play failed:', err));
    }

    // Auto play next track when current ends
    backgroundMusic.addEventListener('ended', () => {
      if (mode === MODE.RACING) {
        playRandomMusic();
      }
    });

    // Winner cinematic
    let winCine = { active: false, horse: null, phase: 'SPRINT', startAt: 0, finishAt: 0 };
    let cameraOffset = 0; // For scrolling background

    // Obstacle scheduler
    const maxEliminationPercent = 0.30;
    let nextObstacleAt = 0;
    let obstacleInProgress = false;
    const OBSTACLE_GAP_MIN = 5000;
    const OBSTACLE_GAP_MAX = 12000;

    // Overtake drama
    let nextOvertakeAt = 0;
    const OVERTAKE_GAP_MIN = 5000;
    const OVERTAKE_GAP_MAX = 6500;

    // Animation frame counter
    let frameCount = 0;

    // ===== Drawing Functions =====
    function drawSky() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.25);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(1, '#E0F6FF');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height * 0.25);
    }

    function drawGround() {
      // Sky takes less space, track takes more
      const skyHeight = canvas.height * 0.25;

      // Grass
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(0, skyHeight, canvas.width, canvas.height * 0.1);

      // Track (dirt) - much larger now
      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(0, trackY, canvas.width, trackHeight);

      // Track lines
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, trackY);
      ctx.lineTo(canvas.width, trackY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, trackY + trackHeight);
      ctx.lineTo(canvas.width, trackY + trackHeight);
      ctx.stroke();

      // Grass texture lines (scrolling)
      ctx.strokeStyle = 'rgba(34,139,34,0.3)';
      ctx.lineWidth = 2;
      const grassSpacing = 40;
      const grassOffset = cameraOffset * 0.8;
      for (let x = -(grassOffset % grassSpacing); x < canvas.width; x += grassSpacing) {
        ctx.beginPath();
        ctx.moveTo(x, skyHeight);
        ctx.lineTo(x + 20, skyHeight + canvas.height * 0.1);
        ctx.stroke();
      }
    }

    function drawCloud(cloud) {
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      const x = cloud.x - cameraOffset * 0.3; // Parallax effect
      ctx.beginPath();
      ctx.arc(x, cloud.y, 30, 0, Math.PI * 2);
      ctx.arc(x + 25, cloud.y, 35, 0, Math.PI * 2);
      ctx.arc(x + 50, cloud.y, 30, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawTree(tree) {
      const x = tree.x - cameraOffset * 0.5; // Parallax effect
      // Trunk
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(x - 8, tree.y, 16, 40);

      // Leaves
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(x, tree.y - 10, 25, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawFinishLine() {
      const x = canvas.width - 100;
      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;

      // Checkered flag pattern
      const squareSize = 15;
      for (let row = 0; row < Math.ceil(trackHeight / squareSize); row++) {
        for (let col = 0; col < 3; col++) {
          const isWhite = (row + col) % 2 === 0;
          ctx.fillStyle = isWhite ? '#fff' : '#000';
          ctx.fillRect(x + col * squareSize, trackY + row * squareSize, squareSize, squareSize);
        }
      }

      // Trophy at top
      ctx.font = 'bold 60px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('üèÜ', x + 22, trackY - 20);
    }

    function drawHorse(horse, laneIndex) {
      if (eliminatedHorses.includes(horse.name)) return;
      if (!horseImgLoaded) return; // Wait for image to load

      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;

      // All horses run on the same track area with depth offset
      const centerY = trackY + trackHeight * 0.5 + horse.depthOffset;

      // Calculate screen position based on horse position minus camera offset
      let x;
      if (mode === MODE.WIN_CINEMATIC && horse.isWinner) {
        // Winner sprints across screen
        x = horse.position;
      } else {
        // Normal mode: position minus camera offset for scrolling effect
        x = horse.position - cameraOffset + canvas.width * 0.2;
      }

      // Culling: skip drawing if horse is off-screen (optimization)
      if (!horse.isWinner && (x < -200 || x > canvas.width + 200)) {
        return;
      }

      const y = centerY;

      // Fixed scale for all - larger and consistent
      let baseScale = 0.2; // Larger base scale
      let scale = baseScale;

      // Gallop animation (gentle bounce)
      const gallopPhase = frameCount * 0.3 * (horse.speed / 2);
      const gallopOffset = Math.abs(Math.sin(gallopPhase)) * (5 * scale / baseScale);
      const horseY = y - gallopOffset;

      // Body bounce (minimal tilt)
      const bodyTilt = Math.sin(gallopPhase) * 0.015;

      const horseWidth = horseImg.width * scale;
      const horseHeight = horseImg.height * scale;

      ctx.save();
      ctx.translate(x, horseY);
      ctx.rotate(bodyTilt);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, horseHeight * 0.4, horseWidth * 0.35, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Apply color filter based on horse.hueRotate
      if (horse.hueRotate !== undefined) {
        ctx.filter = `hue-rotate(${horse.hueRotate}deg) saturate(1.2)`;
      }

      // Draw animated horse GIF
      ctx.drawImage(horseImg, -horseWidth / 2, -horseHeight / 2, horseWidth, horseHeight);

      // Reset filter
      ctx.filter = 'none';

      ctx.restore();

      // Name tag - fixed position, no bouncing
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformation for name tag

      // Dynamic font size based on number of players (very large)
      let fontSize = 32;
      if (horses.length > 50) fontSize = 22;
      else if (horses.length > 30) fontSize = 26;
      else if (horses.length > 20) fontSize = 28;
      else if (horses.length > 10) fontSize = 30;

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeStyle = horse.color;
      ctx.lineWidth = 2;
      ctx.font = `bold ${fontSize}px Quicksand`;
      const nameWidth = ctx.measureText(horse.name).width + 20;

      const tagX = x - nameWidth/2;
      // Use centerY instead of horseY for stable position (adjusted for larger horse)
      const tagY = centerY - (horseHeight * 0.8);
      const tagHeight = fontSize + 8;

      // Rounded rectangle for name tag
      const radius = 6;
      ctx.beginPath();
      ctx.moveTo(tagX + radius, tagY);
      ctx.lineTo(tagX + nameWidth - radius, tagY);
      ctx.quadraticCurveTo(tagX + nameWidth, tagY, tagX + nameWidth, tagY + radius);
      ctx.lineTo(tagX + nameWidth, tagY + tagHeight - radius);
      ctx.quadraticCurveTo(tagX + nameWidth, tagY + tagHeight, tagX + nameWidth - radius, tagY + tagHeight);
      ctx.lineTo(tagX + radius, tagY + tagHeight);
      ctx.quadraticCurveTo(tagX, tagY + tagHeight, tagX, tagY + tagHeight - radius);
      ctx.lineTo(tagX, tagY + radius);
      ctx.quadraticCurveTo(tagX, tagY, tagX + radius, tagY);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(horse.name, x, tagY + tagHeight/2);

      ctx.restore();

      // Speed indicator (dust particles) - highly optimized
      if (horse.speed > 3 && horses.length <= 10 && frameCount % 3 === 0) {
        for (let i = 0; i < 2; i++) {
          ctx.fillStyle = `rgba(139, 115, 85, ${0.4 - i * 0.1})`;
          ctx.beginPath();
          const dustX = x - (50 * scale) - i * 12 - (frameCount % 20);
          const dustY = y + (15 * scale) + Math.sin(frameCount * 0.2 + i) * 4;
          const dustSize = (5 - i) * scale;
          ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawObstacle(obstacle) {
      const x = obstacle.x;
      const trackY = canvas.height * 0.35;
      const trackHeight = canvas.height * 0.65;
      const centerY = trackY + trackHeight * 0.5;

      // Draw obstacle as a hurdle
      ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      ctx.fillRect(x - 5, centerY - 40, 10, 80);

      // Hurdle bar
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(x - 30, centerY - 30, 60, 10);
      ctx.fillRect(x - 30, centerY + 20, 60, 10);

      // Warning sign
      ctx.fillStyle = '#ffff00';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö†Ô∏è', x, centerY - 50);
    }

    // ===== Create Entities =====
    function createClouds() {
      clouds = [];
      for (let i = 0; i < 6; i++) {
        clouds.push({
          x: Math.random() * canvas.width,
          y: 50 + Math.random() * 150,
          speed: 0.1 + Math.random() * 0.3
        });
      }
    }

    function createTrees() {
      trees = [];
      for (let i = 0; i < 8; i++) {
        trees.push({
          x: Math.random() * canvas.width,
          y: canvas.height * 0.28 // On grass area, just before track
        });
      }
    }

    function createHorses() {
      const colors = [
        '#8B4513', // N√¢u ƒë·∫•t
        '#654321', // N√¢u s√¥-c√¥-la
        '#D2691E', // N√¢u v√†ng
        '#000000', // ƒêen
        '#FFFFFF', // Tr·∫Øng
        '#A9A9A9', // X√°m
        '#DEB887', // V√†ng c√°t
        '#CD853F', // N√¢u nh·∫°t
        '#B8860B', // V√†ng t·ªëi
        '#8B7355', // N√¢u tan
        '#4A4A4A', // X√°m ƒëen
        '#F5DEB3', // V√†ng be
        '#C19A6B', // N√¢u camel
        '#6F4E37', // N√¢u c√† ph√™
        '#483C32'  // N√¢u ƒë·∫≠m
      ];

      horses = [];
      players.forEach((name, idx) => {
        const color = colors[idx % colors.length];
        // Random hue rotation for each horse (0-360 degrees)
        const hueRotate = Math.floor(Math.random() * 360);
        // Random depth offset to create visual separation (spread horses vertically)
        const depthOffset = (Math.random() - 0.5) * canvas.height * 0.4;
        horses.push({
          name,
          color,
          hueRotate, // For color variation in GIF
          depthOffset, // Vertical position variation
          position: 80, // Start further right to show full horse body
          speed: rand(1.5, 2.5),
          targetSpeed: rand(1.5, 2.5),
          stamina: 1.0,
          burstCD: 0,
          slipCD: 0,
          scriptedBoostUntil: 0,
          scriptedFatigueUntil: 0,
          isWinner: false
        });
      });
    }

    function createObstacles() {
      obstacles = [];
      const count = 5; // Reduced from 8 for better performance
      for (let i = 0; i < count; i++) {
        obstacles.push({
          x: 200 + i * (canvas.width - 300) / count,
          active: false,
          used: false,
          cooldown: 0
        });
      }
    }

    // ===== Game Logic =====
    function tryScheduleObstacle() {
      const elapsed = (Date.now() - raceStartTime) / 1000;
      const remaining = Math.max(0, raceDuration - elapsed);

      const elimLimit = Math.floor(totalPlayers * maxEliminationPercent);
      const canEliminateMore = eliminatedHorses.length < elimLimit;

      if (!canEliminateMore) return;
      if (remaining <= 4) return;
      if (obstacleInProgress) return;
      if (Date.now() < nextObstacleAt) return;

      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (!alive.length) return;

      const sorted = [...alive].sort((a,b) => b.position - a.position);
      const topK = sorted.slice(0, Math.max(2, Math.floor(sorted.length * 0.5)));
      const targetHorse = pick(topK);

      // Find nearest unused obstacle
      let best = null;
      let bestDist = Infinity;
      for (const ob of obstacles) {
        if (ob.used || ob.cooldown > 0) continue;
        const dist = Math.abs(targetHorse.position - ob.x);
        if (dist < bestDist && dist < 150) {
          bestDist = dist;
          best = ob;
        }
      }

      if (best) {
        best.active = true;
        best.targetHorse = targetHorse;
        obstacleInProgress = true;
        addEventLog(`‚ö†Ô∏è Ch∆∞·ªõng ng·∫°i v·∫≠t xu·∫•t hi·ªán! ${targetHorse.name} ƒëang l·∫°i g·∫ßn...`, 'info');
      }

      nextObstacleAt = Date.now() + Math.floor(rand(OBSTACLE_GAP_MIN, OBSTACLE_GAP_MAX));
    }

    function scheduleOvertakeIfNeeded() {
      if (Date.now() < nextOvertakeAt) return;
      nextOvertakeAt = Date.now() + Math.floor(rand(OVERTAKE_GAP_MIN, OVERTAKE_GAP_MAX));

      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (alive.length < 2) return;

      const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));
      const candidates = alive.filter(h => h.name !== leader.name);
      const chosen = pick(candidates);

      const now = Date.now();
      chosen.scriptedBoostUntil = now + 2200 + Math.floor(Math.random() * 400);
      chosen.scriptedFatigueUntil = chosen.scriptedBoostUntil + 1600 + Math.floor(Math.random() * 500);

      addEventLog(`‚ö° ${chosen.name} tƒÉng t·ªëc ƒë·ªôt ng·ªôt! C·ªë g·∫Øng v∆∞·ª£t qua ${leader.name}!`, 'info');
      setTimeout(() => {
        if (!winner && !eliminatedHorses.includes(chosen.name)) {
          addEventLog(`üí® ${chosen.name} gi·∫£m t·ªëc ƒë·ªô...`, 'info');
        }
      }, 2300);
    }

    function updateHorses() {
      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));
      if (!alive.length) return;

      const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));

      horses.forEach(horse => {
        if (eliminatedHorses.includes(horse.name)) return;

        // Don't update regular horses in cinematic mode
        if (mode === MODE.WIN_CINEMATIC && !horse.isWinner) return;

        horse.burstCD = Math.max(0, horse.burstCD - 1);
        horse.slipCD = Math.max(0, horse.slipCD - 1);

        const drain = Math.max(0, horse.speed - 2.5) * 0.003;
        const regen = Math.max(0, 2.8 - horse.speed) * 0.002;
        horse.stamina = clamp(horse.stamina - drain + regen, 0, 1);

        const distFromLeader = Math.abs(horse.position - leader.position);
        if (distFromLeader > 80) horse.targetSpeed = Math.max(horse.targetSpeed, 3.0);
        if (distFromLeader < 20) horse.targetSpeed = Math.min(horse.targetSpeed, 2.0);

        horse.targetSpeed = clamp(horse.targetSpeed + (Math.random() - 0.5) * 0.1, 1.5, 4.5);

        const now = Date.now();
        if (now < horse.scriptedBoostUntil) horse.targetSpeed = Math.max(horse.targetSpeed, 5.0);
        else if (now < horse.scriptedFatigueUntil) horse.targetSpeed = Math.min(horse.targetSpeed, 2.0);

        if (horse.burstCD === 0 && horse.stamina > 0.35 && Math.random() < 0.012) {
          horse.targetSpeed = 4.5 + Math.random() * 1.5;
          horse.stamina = Math.max(0, horse.stamina - 0.22);
          horse.burstCD = 95;
        }
        if (horse.slipCD === 0 && horse.stamina < 0.25 && Math.random() < 0.01) {
          horse.targetSpeed = 1.5 + Math.random() * 0.8;
          horse.slipCD = 85;
        }

        horse.speed += (horse.targetSpeed - horse.speed) * 0.08;
        horse.position += horse.speed;

        // Only limit position during cinematic mode
        if (mode === MODE.WIN_CINEMATIC && horse.isWinner) {
          horse.position = Math.min(horse.position, canvas.width - 120);
        }
      });
    }

    function updateObstacles() {
      obstacles.forEach(ob => {
        if (ob.cooldown > 0) ob.cooldown--;

        if (ob.active && ob.targetHorse) {
          const horse = ob.targetHorse;
          if (eliminatedHorses.includes(horse.name)) {
            ob.active = false;
            ob.used = true;
            ob.cooldown = 180;
            obstacleInProgress = false;
            return;
          }

          if (Math.abs(horse.position - ob.x) < 30) {
            eliminatedHorses.push(horse.name);
            addEventLog(`üí• ${horse.name} va ph·∫£i ch∆∞·ªõng ng·∫°i v·∫≠t v√† b·ªã lo·∫°i!`, 'eliminated');
            
            // Flash event log for attention on elimination
            eventLog.style.animation = 'none';
            setTimeout(() => eventLog.style.opacity = '1', 10);

            ob.active = false;
            ob.used = true;
            ob.cooldown = 180;
            obstacleInProgress = false;

            const elimLimit = Math.floor(totalPlayers * maxEliminationPercent);
            const remaining = totalPlayers - eliminatedHorses.length;
            if (eliminatedHorses.length >= elimLimit) {
              addEventLog(`‚úÖ Kh√¥ng c√≤n ch∆∞·ªõng ng·∫°i v·∫≠t! ${remaining} ng·ª±a c√≤n l·∫°i!`, 'info');
            } else {
              addEventLog(`‚ö†Ô∏è C√≤n ${elimLimit - eliminatedHorses.length} ng·ª±a c√≥ th·ªÉ b·ªã lo·∫°i n·ªØa!`, 'info');
            }
          }
        }
      });
    }

    function checkWinner() {
      const elapsed = (Date.now() - raceStartTime) / 1000;
      const alive = horses.filter(h => !eliminatedHorses.includes(h.name));

      // Only declare winner when time is up
      if (elapsed >= raceDuration && !winner) {
        const leader = alive.reduce((a,b) => (b.position > a.position ? b : a));
        setWinner(leader.name, `‚è∞ H·∫øt gi·ªù! ${leader.name} v·ªÅ ƒë√≠ch!`);
      }
    }

    function setWinner(name, reasonText) {
      if (winner) return;
      winner = name;

      const wh = horses.find(h => h.name === name);
      if (!wh) return;

      wh.isWinner = true;
      addEventLog(reasonText, 'caught');

      // Don't reset position - let winner sprint from current position!
      // wh.position stays as-is in the pack

      // Start cinematic
      mode = MODE.WIN_CINEMATIC;
      winCine.active = true;
      winCine.horse = wh;
      winCine.phase = 'SPRINT';
      winCine.startAt = Date.now();
      winCine.finishAt = 0;

      // Hide event log during cinematic
      eventLog.classList.add('hidden');

      // Stop obstacles
      obstacles.forEach(ob => {
        ob.isCatching = false;
      });
      obstacleInProgress = false;
    }

    function updateWinnerCinematic(time) {
      if (!winCine.active || !winCine.horse) return;
      const wh = winCine.horse;

      if (winCine.phase === 'SPRINT') {
        // Winner bursts forward from the pack with dramatic speed boost!
        wh.targetSpeed = 10.0; // Faster than normal for dramatic effect
        wh.speed += (wh.targetSpeed - wh.speed) * 0.2;
        wh.position += wh.speed;

        // Camera follows winner smoothly as they sprint ahead
        const targetCameraOffset = wh.position - canvas.width * 0.4; // Keep winner at 40% of screen
        cameraOffset += (targetCameraOffset - cameraOffset) * 0.15;

        // Simple finish condition - after sprinting for 3 seconds or traveled far enough
        const sprintDuration = (Date.now() - winCine.startAt) / 1000;
        const distanceTraveled = wh.position - (cameraOffset + canvas.width * 0.2);
        
        // Check if winner has sprinted long enough (3 seconds) or far enough ahead
        if (sprintDuration >= 3.0 || distanceTraveled > canvas.width * 0.5) {
          winCine.phase = 'CELEBRATE';
          winCine.finishAt = Date.now();
          addEventLog(`üèÜ ${wh.name} v·ªÅ ƒë√≠ch ƒë·∫ßu ti√™n!`, 'caught');
        }
      }

      if (winCine.phase === 'CELEBRATE') {
        const elapsed = Date.now() - winCine.finishAt;

        // Continue camera movement slowly
        cameraOffset += 0.5;

        if (elapsed > 1500) {
          winCine.phase = 'SHOW';
          announceWinnerUI();
        }
      }
    }

    function announceWinnerUI() {
      mode = MODE.ENDED;
      winCine.active = false;

      winnerNameEl.textContent = winner;
      winnerPanel.classList.remove('hidden');
      setTimeout(() => winnerPanel.classList.add('show'), 100);
      createConfetti();

      // Stop racing music and play victory music
      stopMusic();
      playVictoryMusic();
    }

    // ===== Confetti =====
    const confettiParticles = [];
    function createConfetti() {
      const colors = ['#ff6b81', '#70a1ff', '#feca57', '#48dbfb', '#ff6348'];
      for (let i = 0; i < 60; i++) {
        confettiParticles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 5 + Math.random() * 10,
          speedY: 2 + Math.random() * 3,
          speedX: (Math.random() - 0.5) * 2,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.2
        });
      }
    }

    function drawConfetti() {
      confettiParticles.forEach((p, index) => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        ctx.restore();

        p.y += p.speedY;
        p.x += p.speedX;
        p.rotation += p.rotationSpeed;

        if (p.y > canvas.height) {
          confettiParticles.splice(index, 1);
        }
      });
    }

    // ===== Main Game Loop =====
    function gameLoop() {
      requestAnimationFrame(gameLoop);

      frameCount++;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      drawSky();

      // Update and draw clouds (optimized, only every 2 frames)
      if (frameCount % 2 === 0) {
        clouds.forEach(cloud => {
          cloud.x -= cloud.speed;
          if (cloud.x - cameraOffset * 0.3 < -100) cloud.x = canvas.width + cameraOffset * 0.3 + 100;
          drawCloud(cloud);
        });
      } else {
        clouds.forEach(cloud => drawCloud(cloud));
      }

      drawGround();

      // Draw trees (optimized - skip if off screen)
      trees.forEach(tree => {
        const treeScreenX = tree.x - cameraOffset * 0.5;
        if (treeScreenX < -100 || treeScreenX > canvas.width + 100) {
          if (tree.x - cameraOffset * 0.5 < -50) {
            tree.x = canvas.width + cameraOffset * 0.5 + 50;
          }
          return;
        }
        drawTree(tree);
      });

      // Draw finish line only in cinematic mode
      if (mode === MODE.WIN_CINEMATIC) {
        drawFinishLine();
      }

      if (mode === MODE.WIN_CINEMATIC) {
        // Update time display
        const elapsed = (Date.now() - raceStartTime) / 1000;
        const remaining = Math.max(0, raceDuration - elapsed);
        const timeEl = document.getElementById('timeRemaining');
        if (timeEl) timeEl.textContent = `‚è±Ô∏è ${Math.ceil(remaining)}s`;

        // Update winner cinematic (this updates winner horse and camera)
        updateWinnerCinematic(Date.now() * 0.001);

        // Update other horses position for tracking (they stay on screen but still "race")
        horses.forEach(horse => {
          if (!horse.isWinner && !eliminatedHorses.includes(horse.name)) {
            horse.position += horse.speed;
          }
        });

        // Draw horses sorted by position (back to front for depth effect)
        // Cache sorting to improve performance - only sort every 5 frames
        if (frameCount - lastSortFrame > 5 || lastSortFrame === -1) {
          sortedHorsesCache = [...horses].sort((a, b) => a.position - b.position);
          lastSortFrame = frameCount;
        }
        sortedHorsesCache.forEach((horse, idx) => drawHorse(horse, idx));

        return;
      }

      if (mode === MODE.RACING) {
        // Update time
        const elapsed = (Date.now() - raceStartTime) / 1000;
        const remaining = Math.max(0, raceDuration - elapsed);
        const timeEl = document.getElementById('timeRemaining');
        if (timeEl) timeEl.textContent = `‚è±Ô∏è ${Math.ceil(remaining)}s`;

        // Update game logic
        updateHorses();
        updateObstacles();
        tryScheduleObstacle();
        scheduleOvertakeIfNeeded();
        checkWinner();

        // Update camera offset to keep horses on left side of screen
        const aliveHorses = horses.filter(h => !eliminatedHorses.includes(h.name));
        if (aliveHorses.length > 0) {
          // Calculate average position of all alive horses
          const avgPosition = aliveHorses.reduce((sum, h) => sum + h.position, 0) / aliveHorses.length;
          // Camera follows the pack to keep them at 20% of screen (left-center for better view)
          const targetCameraOffset = avgPosition - canvas.width * 0.2;
          // Smooth camera movement
          cameraOffset += (targetCameraOffset - cameraOffset) * 0.15;

          // Log leader - reduced frequency for performance
          const leader = aliveHorses.reduce((a,b) => (b.position > a.position ? b : a));
          const sec = Math.floor(elapsed);
          if (sec > 0 && sec % 7 === 0 && !window['lead_' + sec]) {
            window['lead_' + sec] = true;
            const topSpeed = Math.max(...aliveHorses.map(h => h.speed)).toFixed(1);
            addEventLog(`üèÜ ${leader.name} ƒëang d·∫´n ƒë·∫ßu! (T·ªëc ƒë·ªô: ${topSpeed})`, 'info');
            // Flash race info for attention
            raceInfo.style.animation = 'none';
            setTimeout(() => raceInfo.style.animation = 'infoPulse 2s ease-in-out infinite', 10);
          }
        }

        // Draw obstacles
        obstacles.forEach(ob => {
          if (!ob.used) drawObstacle(ob);
        });
      }

      // Draw horses sorted by position (back to front for depth effect)
      // Cache sorting to improve performance - only sort every 5 frames
      if (frameCount - lastSortFrame > 5 || lastSortFrame === -1 || sortedHorsesCache.length === 0) {
        sortedHorsesCache = [...horses].sort((a, b) => a.position - b.position);
        lastSortFrame = frameCount;
      }
      sortedHorsesCache.forEach((horse, idx) => drawHorse(horse, idx));

      // Draw confetti
      if (confettiParticles.length > 0) {
        drawConfetti();
      }
    }

    // ===== Reset / Start =====
    function resetRace() {
      winner = null;
      eliminatedHorses = [];
      horses = [];
      obstacles = [];
      confettiParticles.length = 0;
      frameCount = 0;
      cameraOffset = 0;
      sortedHorsesCache = [];
      lastSortFrame = -1;

      winCine = { active: false, horse: null, phase: 'SPRINT', startAt: 0, finishAt: 0 };

      nextObstacleAt = Date.now() + 2500;
      obstacleInProgress = false;
      nextOvertakeAt = Date.now() + 4500;

      // Show event log again
      eventLog.classList.remove('hidden');
    }

    function startRace() {
      resetRace();

      totalPlayers = players.length;
      createClouds();
      createTrees();
      createHorses();
      createObstacles();

      raceStartTime = Date.now();
      mode = MODE.RACING;

      raceInfo.style.display = 'block';
      eventLog.style.display = 'block';

      addEventLog('üèÅ Cu·ªôc ƒëua b·∫Øt ƒë·∫ßu!', 'info');

      // Start background music
      playRandomMusic();
    }

    // ===== Event Listeners =====
    playerInput.addEventListener('input', () => {
      const text = playerInput.value.trim();
      players = text ? text.split('\n').map(s => s.trim()).filter(Boolean) : [];
      startBtn.disabled = players.length < 2;
    });

    startBtn.addEventListener('click', () => {
      const text = playerInput.value.trim();
      if (!text) return alert('Vui l√≤ng nh·∫≠p danh s√°ch ng∆∞·ªùi ch∆°i!');
      players = text.split('\n').map(s => s.trim()).filter(Boolean);
      if (players.length < 2) return alert('C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i!');

      raceDuration = Math.max(1, parseInt(raceDurationInput.value, 10) || 30);

      setupPanel.classList.add('hidden');
      const timeEl = document.getElementById('timeRemaining');
      if (timeEl) timeEl.textContent = `‚è±Ô∏è ${raceDuration}s`;

      startRace();
    });

    restartBtn.addEventListener('click', () => location.reload());

    // ===== Initialize =====
    createClouds();
    createTrees();
    gameLoop();
  </script>
</body>
</html>
